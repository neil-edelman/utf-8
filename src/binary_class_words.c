/** @license mit @std c11

 I realize that this is just starting on a project that is going to turn into…
 re2c. <https://re2c.org/manual/manual_c.html#encoding-support> has, since
 2019, already there. So that's quite easy, I guess. It's even got Graphviz
 support. */

#include <inttypes.h>

/* <!-- input: generate.c */
static const uint32_t utf32_word_edges[] = {
	/* 8 code-points. */
	0x30, 0x3a, 0x41, 0x5b, 0x5f, 0x60, 0x61, 0x7b,
	/* 68 code-points. */
	0xc2aa, 0xc2ab, 0xc2b2, 0xc2b4, 0xc2b5, 0xc2b6, 0xc2b9, 0xc2bb, 0xc2bc,
	0xc2bf, 0xc380, 0xc397, 0xc398, 0xc3b7, 0xc3b8, 0xcb82, 0xcb86, 0xcb92,
	0xcba0, 0xcba5, 0xcbac, 0xcbad, 0xcbae, 0xcbaf, 0xcc80, 0xcdb5, 0xcdb6,
	0xcdbe, 0xcdbf, 0xce84, 0xce86, 0xce87, 0xce88, 0xcfb6, 0xcfb7, 0xd282,
	0xd283, 0xd59a, 0xd5a0, 0xd689, 0xd691, 0xd6be, 0xd6bf, 0xd780, 0xd781,
	0xd783, 0xd784, 0xd786, 0xd787, 0xd7b3, 0xd890, 0xd89b, 0xd8a0, 0xd9aa,
	0xd9ae, 0xdb94, 0xdb95, 0xdb9d, 0xdb9f, 0xdba9, 0xdbaa, 0xdbbd, 0xdbbf,
	0xdc80, 0xdc90, 0xdfb6, 0xdfba, 0xdfbe,
	/* 310 code-points. */
	0xe0a080, 0xe0a0b0, 0xe0a180, 0xe0a19e, 0xe0a1a0, 0xe0a288, 0xe0a289,
	0xe0a290, 0xe0a297, 0xe0a3a2, 0xe0a3a3, 0xe0a5a4, 0xe0a5a6, 0xe0a5b0,
	0xe0a5b1, 0xe0a7b2, 0xe0a7b4, 0xe0a7ba, 0xe0a7bc, 0xe0a7bd, 0xe0a7be,
	0xe0a9b6, 0xe0aa81, 0xe0abb0, 0xe0abb9, 0xe0adb0, 0xe0adb1, 0xe0afb3,
	0xe0b080, 0xe0b1b7, 0xe0b1b8, 0xe0b1bf, 0xe0b280, 0xe0b284, 0xe0b285,
	0xe0b58f, 0xe0b594, 0xe0b5b9, 0xe0b5ba, 0xe0b7b4, 0xe0b881, 0xe0b8bf,
	0xe0b980, 0xe0b98f, 0xe0b990, 0xe0b99a, 0xe0ba81, 0xe0bc81, 0xe0bc98,
	0xe0bc9a, 0xe0bca0, 0xe0bcb4, 0xe0bcb5, 0xe0bcb6, 0xe0bcb7, 0xe0bcb8,
	0xe0bcb9, 0xe0bcba, 0xe0bcbe, 0xe0be85, 0xe0be86, 0xe0bebe, 0xe0bf86,
	0xe0bf87, 0xe18080, 0xe1818a, 0xe18190, 0xe1829e, 0xe182a0, 0xe183bb,
	0xe183bc, 0xe18da0, 0xe18da9, 0xe18e90, 0xe18ea0, 0xe19080, 0xe19081,
	0xe199ad, 0xe199af, 0xe19a80, 0xe19a81, 0xe19a9b, 0xe19aa0, 0xe19bab,
	0xe19bae, 0xe19cb5, 0xe19d80, 0xe19f94, 0xe19f97, 0xe19f98, 0xe19f9c,
	0xe1a080, 0xe1a08b, 0xe1a08e, 0xe1a08f, 0xe1a580, 0xe1a586, 0xe1a79e,
	0xe1a880, 0xe1a89e, 0xe1a8a0, 0xe1aaa0, 0xe1aaa7, 0xe1aaa8, 0xe1aab0,
	0xe1ad8e, 0xe1ad90, 0xe1ad9a, 0xe1adab, 0xe1adb4, 0xe1ae80, 0xe1afbc,
	0xe1b080, 0xe1b0bb, 0xe1b180, 0xe1b1be, 0xe1b280, 0xe1b380, 0xe1b390,
	0xe1b393, 0xe1b394, 0xe1bebd, 0xe1bebe, 0xe1bebf, 0xe1bf82, 0xe1bf8d,
	0xe1bf90, 0xe1bf9d, 0xe1bfa0, 0xe1bfad, 0xe1bfb2, 0xe1bfbd, 0xe2808b,
	0xe2808e, 0xe280bf, 0xe28181, 0xe28194, 0xe28195, 0xe281a0, 0xe281a1,
	0xe281b0, 0xe281ba, 0xe281bf, 0xe2828a, 0xe28290, 0xe282a0, 0xe28390,
	0xe28480, 0xe28482, 0xe28483, 0xe28487, 0xe28488, 0xe2848a, 0xe28494,
	0xe28495, 0xe28496, 0xe28499, 0xe2849e, 0xe284a4, 0xe284a5, 0xe284a6,
	0xe284a7, 0xe284a8, 0xe284a9, 0xe284aa, 0xe284ae, 0xe284af, 0xe284ba,
	0xe284bc, 0xe28580, 0xe28585, 0xe2858a, 0xe2858e, 0xe2858f, 0xe28590,
	0xe2868a, 0xe291a0, 0xe2929c, 0xe293aa, 0xe29480, 0xe29db6, 0xe29e94,
	0xe2b080, 0xe2b3a5, 0xe2b3ab, 0xe2b3b9, 0xe2b3bd, 0xe2b3be, 0xe2b480,
	0xe2b5b0, 0xe2b5bf, 0xe2b880, 0xe2b8af, 0xe2b8b0, 0xe38085, 0xe38088,
	0xe380a1, 0xe380b0, 0xe380b1, 0xe380b6, 0xe380b8, 0xe380bd, 0xe38181,
	0xe3829b, 0xe3829d, 0xe382a0, 0xe382a1, 0xe383bb, 0xe383bc, 0xe38690,
	0xe38692, 0xe38696, 0xe386a0, 0xe38780, 0xe387b0, 0xe38880, 0xe388a0,
	0xe388aa, 0xe38988, 0xe38990, 0xe38991, 0xe389a0, 0xe38a80, 0xe38a8a,
	0xe38ab1, 0xe38b80, 0xe39080, 0xe4b780, 0xe4b880, 0xea9290, 0xea9390,
	0xea93be, 0xea9480, 0xea988d, 0xea9890, 0xea99b3, 0xea99b4, 0xea99be,
	0xea99bf, 0xea9bb2, 0xea9c97, 0xea9ca0, 0xea9ca2, 0xea9e89, 0xea9e8b,
	0xeaa0a8, 0xeaa0ac, 0xeaa0b6, 0xeaa180, 0xeaa1b4, 0xeaa280, 0xeaa38e,
	0xeaa390, 0xeaa3b8, 0xeaa3bb, 0xeaa3bc, 0xeaa3bd, 0xeaa4ae, 0xeaa4b0,
	0xeaa59f, 0xeaa5a0, 0xeaa781, 0xeaa78f, 0xeaa79e, 0xeaa7a0, 0xeaa99c,
	0xeaa9a0, 0xeaa9b7, 0xeaa9ba, 0xeaab9e, 0xeaaba0, 0xeaabb0, 0xeaabb2,
	0xeaad9b, 0xeaad9c, 0xeaadaa, 0xeaadb0, 0xeaafab, 0xeaafac, 0xeda080,
	0xefa480, 0xefaca9, 0xefacaa, 0xefaeb2, 0xefaf93, 0xefb4be, 0xefb590,
	0xefb78f, 0xefb7b0, 0xefb7bc, 0xefb880, 0xefb890, 0xefb8a0, 0xefb8b0,
	0xefb8b3, 0xefb8b5, 0xefb98d, 0xefb990, 0xefb9b0, 0xefbbbf, 0xefbc90,
	0xefbc9a, 0xefbca1, 0xefbcbb, 0xefbcbf, 0xefbd80, 0xefbd81, 0xefbd9b,
	0xefbda6, 0xefbfa0,
	/* 203 code-points. */
	0xf0908480, 0xf0908487, 0xf09084b7, 0xf0908580, 0xf09085b9, 0xf090868a,
	0xf090868c, 0xf09087bd, 0xf0908e9f, 0xf0908ea0, 0xf0908f90, 0xf0908f91,
	0xf09095af, 0xf09095b0, 0xf090a197, 0xf090a198, 0xf090a1b7, 0xf090a1b9,
	0xf090a49f, 0xf090a4a0, 0xf090a4bf, 0xf090a680, 0xf090a990, 0xf090a9a0,
	0xf090a9bf, 0xf090aa80, 0xf090ab88, 0xf090ab89, 0xf090abb0, 0xf090ac80,
	0xf090acb9, 0xf090ad80, 0xf090ae99, 0xf090aea9, 0xf090b5ae, 0xf090b5af,
	0xf090b68e, 0xf090b9a0, 0xf090baad, 0xf090bab0, 0xf090bd95, 0xf090bdb0,
	0xf090be86, 0xf090beb0, 0xf0918187, 0xf0918192, 0xf09182bb, 0xf0918382,
	0xf091838d, 0xf0918390, 0xf0918580, 0xf0918584, 0xf09185b4, 0xf09185b6,
	0xf0918785, 0xf0918789, 0xf091878d, 0xf091878e, 0xf091879b, 0xf091879c,
	0xf091879d, 0xf09187a1, 0xf09188b8, 0xf09188be, 0xf0918aa9, 0xf0918ab0,
	0xf0918f94, 0xf0918fa1, 0xf091918b, 0xf0919190, 0xf091919a, 0xf091919e,
	0xf0919386, 0xf0919387, 0xf0919781, 0xf0919798, 0xf0919981, 0xf0919984,
	0xf09199a0, 0xf0919a80, 0xf0919ab9, 0xf0919b80, 0xf0919cbc, 0xf0919d80,
	0xf091a0bb, 0xf091a2a0, 0xf091a584, 0xf091a590, 0xf091a7a2, 0xf091a7a3,
	0xf091a8bf, 0xf091a987, 0xf091aa9a, 0xf091aa9d, 0xf091aa9e, 0xf091aab0,
	0xf091ac80, 0xf091af80, 0xf091afa1, 0xf091afb0, 0xf091b181, 0xf091b190,
	0xf091b1b0, 0xf091b1b2, 0xf091bbb7, 0xf091bc80, 0xf091bd83, 0xf091bd90,
	0xf091bf95, 0xf0928080, 0xf09291b0, 0xf0929280, 0xf092bfb1, 0xf0938080,
	0xf09390b0, 0xf0939180, 0xf096a9ae, 0xf096a9b0, 0xf096abb5, 0xf096ac80,
	0xf096acb7, 0xf096ad80, 0xf096ad84, 0xf096ad90, 0xf096b5ad, 0xf096b5b0,
	0xf096ba97, 0xf096bc80, 0xf096bfa2, 0xf096bfa3, 0xf09bb29c, 0xf09bb29d,
	0xf09bb29f, 0xf09cb3b0, 0xf09cb480, 0xf09cbc80, 0xf09cbd90, 0xf09d85a5,
	0xf09d85aa, 0xf09d85ad, 0xf09d85b3, 0xf09d85bb, 0xf09d8683, 0xf09d8685,
	0xf09d868c, 0xf09d86aa, 0xf09d86ae, 0xf09d8982, 0xf09d8985, 0xf09d8b80,
	0xf09d8c80, 0xf09d8da0, 0xf09d9b81, 0xf09d9b82, 0xf09d9b9b, 0xf09d9b9c,
	0xf09d9bbb, 0xf09d9bbc, 0xf09d9c95, 0xf09d9c96, 0xf09d9cb5, 0xf09d9cb6,
	0xf09d9d8f, 0xf09d9d90, 0xf09d9daf, 0xf09d9db0, 0xf09d9e89, 0xf09d9e8a,
	0xf09d9ea9, 0xf09d9eaa, 0xf09d9f83, 0xf09d9f84, 0xf09da080, 0xf09da880,
	0xf09da8b7, 0xf09da8bb, 0xf09da9ad, 0xf09da9b5, 0xf09da9b6, 0xf09daa84,
	0xf09daa85, 0xf09daa9b, 0xf09e858f, 0xf09e8a90, 0xf09e8bbf, 0xf09e9390,
	0xf09e97bf, 0xf09e9fa0, 0xf09ea59e, 0xf09eb1b1, 0xf09eb2ac, 0xf09eb2ad,
	0xf09eb2b0, 0xf09eb2b1, 0xf09eb4ae, 0xf09eb4af, 0xf09ebbb0, 0xf09f8480,
	0xf09f848d, 0xf09fafb0, 0xf3a08081, 0xf3a08480, 0xf3b08080
};
static const uint32_t utf32_word_byte_end[] = { 8, 76, 386, 589 };
/* --> */

/* <!-- from: test_upper_bound.c */
/** @return The majorant of `key` on the set `table` between (`low`, `high`].
 @order O(log `high` - `low`) */
static size_t upper_bound(
	const uint32_t *const table,
	size_t low, size_t high,
	const uint32_t key) {
	while(low < high) {
		size_t mid = low + (high - low) / 2;
		if(table[mid] <= key) low = mid + 1;
		else high = mid;
	}
	return low;
}
/* --> */

#include <stdbool.h>

/* <!-- from: test_is_word.c */
/** Checks whether the first code-point in `string_in_utf8` (it must be
 non-empty) is in [\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}] and `output_next` is the
 potential next code-point, if it isn't the end of the string. Bytes that don't
 appear in utf-8 are false; it sets `output` to the first non-continuation
 byte. <https://www.unicode.org/reports/tr36/>, (seek to a code-point should
 not be dependant on previous code-point's errors.) */
static bool is_word(const char *const string_in_utf8,
		const char **const output_next) {
	union {
		const char *input;
		const uint8_t *unchar;
		char *unconst;
	} string = { .input = string_in_utf8 };
	union { uint32_t u32; uint8_t u8[4]; } internal = { .u32 = 0 };
	size_t edge;

	uint8_t byte = string.unchar[0];
	if(byte < 0x80) { /* 1 byte? */
		internal.u8[0] = byte;
		edge = upper_bound(utf32_word_edges, 0, utf32_word_byte_end[0],
			internal.u32);
		*output_next = string.unconst + 1;
	} else if((byte & 0xe0) == 0xc0) { /* 2 bytes continued? */
		internal.u8[1] = byte;
		byte = string.unchar[1];
		if((byte & 0xc0) != 0x80)
			return *output_next = string.unconst + 1, false;
		internal.u8[0] = byte;
		edge = upper_bound(utf32_word_edges, utf32_word_byte_end[0], utf32_word_byte_end[1], internal.u32);
		*output_next = string.unconst + 2;
	} else if((byte & 0xf0) == 0xe0) { /* 3 bytes continued? */
		internal.u8[2] = byte;
		byte = string.unchar[1];
		if((byte & 0xc0) != 0x80)
			return *output_next = string.unconst + 1, false;
		internal.u8[1] = byte;
		byte = string.unchar[2];
		if((byte & 0xc0) != 0x80)
			return *output_next = string.unconst + 2, false;
		internal.u8[0] = byte;
		edge = upper_bound(utf32_word_edges, utf32_word_byte_end[1], utf32_word_byte_end[2], internal.u32);
		*output_next = string.unconst + 3;
	} else if((byte & 0xf8) == 0xf0) { /* 4 bytes continued? */
		internal.u8[3] = byte;
		byte = string.unchar[1];
		if((byte & 0xc0) != 0x80)
			return *output_next = string.unconst + 1, false;
		internal.u8[2] = byte;
		byte = string.unchar[2];
		if((byte & 0xc0) != 0x80)
			return *output_next = string.unconst + 2, false;
		internal.u8[1] = byte;
		byte = string.unchar[3];
		if((byte & 0xc0) != 0x80)
			return *output_next = string.unconst + 3, false;
		internal.u8[0] = byte;
		edge = upper_bound(utf32_word_edges, utf32_word_byte_end[2], utf32_word_byte_end[3], internal.u32);
		*output_next = string.unconst + 4;
	} else {
		/* Not normalized utf-8 (16.0.0 #44) character. Maybe… */
		return *output_next = string.unconst + 1, false;
	}
	return edge & 1;
}
/* --> */

//struct word { union { const char *c; const uint8_t *u; } start, end; };

#include <stdlib.h>
#include <stdio.h>

static void split(const char *const split) {
	struct {
		bool last, word;
		const char *lastword;
	} state = {0};
	const char *s = split;
	printf("->%s\n", s);
	while(*s != '\0') {
		const char *const lastword = s;
		state.word = is_word(s, &s);
		if(!state.word ^ state.last) continue;
		state.last = state.word;
		if(state.word) state.lastword = lastword;
		else printf("\"%.*s\"\n", (int)(s - 1 - state.lastword), state.lastword);
	}
	if(state.word) printf("\"%.*s\"\n", (int)(s - state.lastword), state.lastword);
}

int main(void) {
	const char *sentence[] = {
		"one two", //2
		"one,two", //2
		"one.two", //2
		"one_two", //1 (1)
		"one—two", //2
		"0.0 a.b", //4
		"fi f‌iii", //2 (U+200C zwnj is in the second)
		"manœuver…æroplane non-joinerfif‌‌itt‌‌tt what?", // 4 zwnj
		"100,000_000$", // 3 (2)
		"zzzz̀abc de f̀ghi", // 3 (z, U+0300…f, U+0300 combining grave accent)
		"나는  Chicago에  산다" // 3 (actually 5?)
	};
	for(const char **s = sentence,
		**s_end = s + sizeof sentence / sizeof *sentence;
		s < s_end; s++)
		split(*s), printf("\n");

	return EXIT_SUCCESS;
}
